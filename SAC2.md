# Solution Architecture Contract - часть 2 (Agent MVP)

## 1) Цель этой итерации
Добавить в проект реального чат-агента, который в режиме чата принимает задачи на естественном языке и выполняет действия в уже открытом браузере через Playwright MCP tools.

Фокус: базовый decision loop + управление режимами в REPL + подтверждение деструктивных действий.
Без памяти, без advanced техник, без site-specific логики.

## 2) Скоуп и ограничения
### Must
- Агент работает только через MCP tools (launch/observe/click/type/scroll/wait/screenshot).
- Агент не привязан к конкретным сайтам или задачам.
- Агент не использует заранее прошитые селекторы, URL-пути и “подсказки” для кнопок как фиксированные правила.
- Агент выполняет максимум 10 шагов инструментов на один запрос пользователя, затем делает итог и спрашивает продолжать ли.
- Агент должен уметь реагировать на обратную связь пользователя после подведения итогов и продолжать выполнение.
- Подтверждение через policy требуется только для деструктивных действий (оплата, удаление, отправка и т.п.).
- Для логина и других “человеческих” активностей агент передает управление пользователю: сообщает что нужно сделать и останавливается в waiting_user.
  - After the user writes in the chat that they are done, the agent continues from the new state.
- REPL должен поддерживать режим чата: `/chat` включает чат-режим, `/exit` выходит из чат-режима.
  - В чат-режиме любые сообщения (кроме слеш-команд) считаются сообщениями для агента.
  - Чат-режим продолжается, пока пользователь не введет `/exit` или другую слеш-команду.

### Out of scope (не делаем в этой итерации)
- Долгосрочная память, Redis, LangSmith.
- Сложные recovery стратегии, планировщики, мульти-агентность.
- Специфические для сайтов флоу (почта/еда/вакансии как отдельные сценарии).
- Старый граф-заглушка observe -> describe -> wait_user больше не используется как основной режим. Он был только для проверки инфры.

## 3) Поведение и UX в чат-режиме
### 3.1 Общение с пользователем
- Агент общается “как обычный агент”: отвечает по результату, сообщает что получилось/не получилось, просит уточнения при необходимости.
- Внутри decision loop агент не обязан писать промежуточные сообщения пользователю.
- Must: подробные внутренние логи рассуждений LLM идут в Docker logs через python logging.

### 3.2 Итог каждые 10 шагов
После выполнения 10 инструментальных шагов агент обязан:
- коротко перечислить что сделал
- перечислить что получилось и что не получилось
- предложить следующий шаг
- спросить продолжать ли, и ждать следующего сообщения пользователя (в чат-режиме) как фидбека или команды продолжения

Продолжение должно быть не командой, а сообщением в чате.

## 4) Сессионное состояние для режима чата
Нужно хранить минимальное состояние на уровне сессии (по `session_id`), чтобы сервер понимал как трактовать вход.

Обязательные элементы состояния:
- `mode`: `"cmd"` | `"chat"`
- `current_goal`: строка - текущая цель/задача в чат-режиме
  - цель обновляется при новом “основном” запросе пользователя
  - цель используется как якорь, чтобы корректно обрабатывать “продолжай”, фидбек и короткие реплики
- `pending_action`: строго одно ожидающее действие, если оно было заблокировано policy до подтверждения
- `pending_kind`: `"none"` | `"confirm"` | `"manual"`
  - confirm: ждём `/yes` или `/no`
  - manual: ждём сообщение пользователя “готово/сделал” после ручного логина или другого вмешательства

Примечание:
- `current_goal` оставляем, даже если историю чата пока отправляем целиком, чтобы позже можно было резать историю без потери намерения.

## 5) Decision loop агента (MVP)
### 5.1 Общий цикл на один запрос пользователя
- Вход: (а) текст пользователя (б) текущая сессия (в) MCP tools.
- Агент делает до 10 итераций:
  - принимает решение, нужно ли сейчас вызвать `observe`
  - выбирает следующий `Action` (один шаг)
  - прогоняет `Action` через policy gate
  - если разрешено, выполняет MCP tool call
  - фиксирует краткий outcome внутри run (временная scratch история только на этот запрос)
- Выход:
  - либо `final` (готовый ответ)
  - либо `waiting_user` (confirm/manual)
  - либо лимит 10 шагов и итог + вопрос продолжать ли

### 5.2 Формат Action
LLM должен возвращать строго структурированный следующий шаг (один).
Action должен покрывать минимум:
- click(eid)
- type(eid, text)
- scroll(direction, amount)
- wait(ms)
- screenshot()
- stop(final_response)
- need_user(reason) - например логин/captcha/2FA/оплата/неясное состояние

Action всегда основан на текущем Observation и истории чата, без site-specific хардкода.

## 6) Policy gate (только whitelist)
Для MVP используется whitelist подход.

### 6.1 Whitelist поведения
- По умолчанию разрешены безопасные классы действий:
  - observe, scroll, wait, screenshot
  - click и type, если действие не классифицировано как деструктивное
- Подтверждение требуется только если действие попадает в “деструктивную” категорию.

### 6.2 Классификация деструктивности
Должна быть эвристической и универсальной (не под сайт), основанной на:
- роли элемента (button/link/form submit)
- accessible name / value / контекстном тексте вокруг элемента, если доступно
- типовых признаках “submit / confirm / pay / delete / send / order” и их распространённых переводах

Важно:
- Это не “blacklist всего остального”.
- Это whitelist разрешённого + отдельный детектор “деструктивности”, который переводит действие в require-confirm.

## 7) Контракт подтверждения (pending_action)
Подтверждение реализуется как стандартный механизм:

- агент предлагает `Action` (например `click eid=X`)
- policy решает `allow` или `need_confirm`
- если `need_confirm`:
  - система сохраняет `pending_action` (строго один)
  - система задаёт вопрос пользователю (policy_request)
  - сессия переходит в `waiting_user` (pending_kind="confirm")
- пользователь пишет `/yes` или `/no`
- если `/yes`:
  - выполняется сохранённый `pending_action`
  - decision loop продолжается
- если `/no`:
  - pending_action сбрасывается
  - агент продолжает с новым решением (или спрашивает что делать дальше)

## 8) Ручное вмешательство пользователя (manual)
Если агент считает, что без человека нельзя продолжить (логин, captcha, 2FA):
- агент пишет что нужно сделать пользователю
- переводит сессию в `waiting_user` (pending_kind="manual")
- после того как пользователь пишет в чате что он закончил (например “готово”), агент:
  - вызывает observe
  - продолжает выполнение от нового состояния страницы

## 9) Лимиты и завершение
- Максимум 10 tool steps на один запрос пользователя.
- По достижению лимита:
  - итог, успех/ошибки, предложение следующего шага
  - вопрос продолжать ли
  - ожидание ответа пользователя в чат-режиме

## 10) События и вывод
- SSE обязателен для наблюдения:
  - observation (summary)
  - tool_call / tool_result
  - policy_request / policy_result
  - error
  - final (итог/summary)
- WebSocket обязателен для чата:
  - user_message
  - agent_message / agent_question
  - status transitions (running/idle/waiting_user/error)

## 11) Критерии приемки
- Пользователь может:
  - открыть страницу вручную
  - включить `/chat`
  - дать задачу на естественном языке
  - агент выполнит действия через MCP tools
- Агент не требует подтверждение для обычных кликов/ввода, но спрашивает `/yes` `/no` перед деструктивными действиями.
- Для логина агент просит пользователя сделать это вручную, ждет сообщение “готово” и продолжает.
- После 10 шагов агент делает итог и принимает фидбек, затем продолжает.
- Чат-режим сохраняется до `/exit` или другой слеш-команды.
