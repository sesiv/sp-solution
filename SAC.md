# Solution Architecture Contract

## 1) Цель
Собрать AI-агента, который автономно управляет видимым браузером для выполнения многошаговых задач, с возможностью:
- вводить задачу в CLI (REPL) или через API
- наблюдать выполнение в реальном браузере
- видеть в терминале вызовы инструментов и аргументы
- запрашивать у пользователя данные и подтверждения только когда это нужно

## 2) Область охвата MVP
MVP фокусируется на инфре и "наблюдении", чтобы потом наращивать логику.

MVP обязуется:
- стартовать браузер (headed)
- обеспечить persistent session (пользователь может залогиниться вручную, агент продолжает)
- уметь получать structured observation и объяснять, что агент видит
- обеспечивать диалоговый режим (не одно сообщение)
- иметь security layer (подтверждение деструктивных действий)

MVP не обязуется:
- решать произвольные задачи на любых сайтах с гарантией успеха (captcha, 2FA, антибот)
- иметь сложный LangGraph граф, планировщик, ретраи и recovery (добавляется позже)

## 3) Нефункциональные требования
- Нельзя отправлять целые страницы в LLM контекст.
- Нельзя хардкодить селекторы, пути URL, тексты кнопок как "подсказки", и шаблоны шагов под конкретные задачи.
- Браузер видимый (не headless).
- Система расширяемая: логика агента меняется без переписывания transport, browser и observation слоев.

## 4) Ключевые технические решения
- Язык: Python.
- Browser control: Playwright MCP (microsoft/playwright-mcp) как единственный слой доступа к браузеру.
- Agent stack: LangChain + LangGraph (на MVP граф минимальный).
- LLM: OpenRouter через LangChain.
- Сервер: FastAPI.
  - WebSocket для двустороннего диалога
  - SSE для стрима событий выполнения (под наблюдение, лог-поток, UI)
- CLI (REPL): Typer + prompt_toolkit + Rich.
- Логи: пока стандартный logging в консоль. Позже LangSmith.
- Redis: позже для кэширования памяти и состояния (не в MVP).

## 5) Архитектурные слои и ответственность

### 5.1 Transport layer (FastAPI)
Отвечает за:
- сессии пользователя и агента
- прием сообщений пользователя
- выдачу событий выполнения (tool calls, observation, ответы)
- cancel, таймауты, статус выполнения

Не отвечает за:
- логику выбора действий
- парсинг страниц

### 5.2 CLI layer (REPL)
Отвечает за:
- интерактивный ввод задач и ответов пользователя
- отображение стрима событий (SSE) и диалога (WS)
- удобный вывод (Rich)

Не отвечает за:
- хранение сессий
- выполнение шагов в браузере

### 5.3 Browser layer (MCP client + Playwright MCP server)
Отвечает за:
- запуск и управление браузером
- persistent sessions (через userDataDir или подключение к существующему профилю, если поддержано конкретной конфигурацией)
- предоставление инструментов: observe, click, type, scroll, wait, screenshot (по возможностям MCP)

Важно:
- Агент не использует Playwright API напрямую.
- Агент не использует CSS/XPath селекторы как постоянные значения.
- Идентификация элементов происходит через eid, сформированный на основе снапшота на текущем шаге.

### 5.4 Observation layer
Отвечает за:
- преобразование сырых данных из MCP observe в компактный Observation
- дедупликацию, нормализацию и ограничение размера данных
- выделение интерактивных элементов и текста видимой области
- обеспечение предсказуемого token budget на шаг

Observation layer не решает задачу пользователя, только подготавливает "что видит агент".

### 5.5 Agent layer (LangChain + LangGraph)
Отвечает за:
- диалог, интерпретацию задач пользователя
- выбор следующего действия на основе Observation
- вызов MCP tools
- запрос недостающей информации у пользователя
- соблюдение security policy

На MVP граф минимальный:
- OBSERVE -> DESCRIBE -> WAIT_USER_INPUT (loop)

Позже расширяется:
- planner/executor, retries, recovery, sub-agents, memory, caching.

### 5.6 Security layer (Policy gate)
Отвечает за:
- блокировку потенциально деструктивных действий без подтверждения
- запрос подтверждения у пользователя
- журналирование decision (как событие)

Подход MVP:
- whitelist безопасных классов действий
- все остальное требует подтверждения пользователя

Примеры потенциально деструктивных:
- оплата, оформление заказа, отправка письма, удаление писем/данных, изменения аккаунта, подтверждения подписок.

## 6) Контракты интерфейсов

### 6.1 FastAPI API

#### WebSocket
`/ws/{session_id}` - двусторонний канал.

Сообщения от клиента:
- user_message: текст
- user_confirm: yes/no + reference на pending action
- control: cancel, pause, resume

Сообщения от сервера:
- agent_message: текст
- agent_question: запрос уточнения
- status: running/idle/waiting_user/error

#### SSE
`/events/{session_id}` - односторонний поток событий выполнения.

События:
- observation: summary и метаданные
- tool_call: name + args
- tool_result: success + краткий результат
- policy_request: что требуется подтвердить
- policy_result: confirmed/denied
- error: описание ошибки + стадия
- final: итог задачи или текущий результат

Смысл разделения:
- WS - управление и чат
- SSE - поток событий, к которому можно подключать несколько наблюдателей (CLI, будущий web UI, запись видео)

### 6.2 Событийная модель (единый формат)
Все события сериализуются как JSON:
- type: строка
- session_id
- ts
- payload: объект

Это ключевой контракт, чтобы менять агента, не ломая CLI/UI.

## 7) Контракт данных Observation

### 7.1 Observation
Минимальные поля:
- page:
  - url
  - title
- interactive: список элементов, максимум N
  - eid: строка (валидна только для текущего observation)
  - role: button/link/textbox/checkbox/...
  - name: accessible name
  - value: если применимо
  - placeholder: если применимо
  - disabled, visible
  - опционально bbox
- text_blocks: список фрагментов видимого текста, максимум M, каждый максимум K символов
- overlays: признаки модалок/баннеров (cookie, гео, подписки), если можно извлечь

### 7.2 Ограничения (token budget)
Observation layer обязуется:
- ограничивать N интерактивных элементов (например 120-200)
- ограничивать M текстовых блоков (например 20-40)
- обрезать длинные строки
- дедуплицировать повторяющиеся name и одинаковые элементы

Причина:
- даже structured accessibility snapshot может быть слишком большим на реальных сайтах
- LLM нужен не полный снимок, а управляемый "экран" для выбора действия

### 7.3 Дозагрузка по требованию (закладываем контракт)
Дополнительные инструменты или режимы observe:
- observe(mode="main") - компактно
- observe(mode="focused", target=eid) - детали вокруг элемента
- get_text_near(eid) - точечный текст

## 8) Контракт на отсутствие хардкода
В коде запрещено:
- страницы-специфичные сценарии ("для hh делай так-то")
- заранее прошитые селекторы
- подсказки типа "страница вакансий это /vacancies" или "кнопка заказать имеет текст Заказать"

Допускается:
- общие эвристики интерфейсов (cookie banner, модалки, логин-форма)
- общие правила ранжирования элементов в observation layer
- security policy по классам действий

## 9) Session contract
- session_id создается сервером или клиентом.
- Сессия мапится на:
  - состояние агента (LangGraph state)
  - состояние браузера (persistent profile dir или подключение к существующему контексту через MCP)
- Сессия живет до явного завершения или таймаута.
- Поддерживается режим WAIT_USER для ручного логина или подтверждения.

## 10) Риски и минимальные меры
- CAPTCHA, 2FA, антибот - агент переводит в WAIT_USER и просит вмешательство.
- Нестабильные страницы и попапы - на MVP допускаются ручные подсказки пользователя, позже добавляется recovery.
- Рост контекста - observation layer обязателен, полный snapshot не отправляется.

## 11) План расширения после MVP (без изменения инфры)
- LangGraph: planner/executor, retries, recovery states.
- Memory: Redis cache для state и краткой истории.
- LangSmith: трассировка шагов агента.
- Более умная policy: LLM-классификатор риска как fallback к whitelist.
- Улучшение observation: focused extraction, ранжирование элементов под цель.
